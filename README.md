# ![][image1]

# MentorMe

**Intern:** Mercy Akinyemi  
**Intern Manager:** Andrew Mo  
**Intern Director:** Josh katz  
**Peer(s):** Chandra Yemparala, Madhulika Balakumar  
**GitHub Repository Link:** [https://github.com/MetaU-projects/FinMind](https://github.com/MetaU-projects/FinMind)    
**Deployed Site:** [https://mentorme-p1nv.onrender.com](https://mentorme-p1nv.onrender.com) 

## Overview

MentorMe is a dynamic, community-powered web platform designed to connect learners (mentees) with experienced individuals (mentors) for peer-led mentoring sessions. The core mission is to democratize access to informal guidance, empower personal growth, and foster meaningful one-on-one learning experiences \-especially for underrepresented communities in tech, education, and career development.

## Problem Statement

Traditional mentorship platforms often rely on rigid structures, exclusive access, or corporate affiliations. MentorMe creates barriers to entry for those without elite networks or institutional backing.  
MentorMe tackles this by offering:

- A decentralized approach to mentorship.  
- A skill-based discovery and recommendation engine.  
- A scheduling system that balances availability across time zones and commitments.  
- Peer accountability without bureaucracy.

## Category

**MentorMe** is a **student-focused mentorship networking platform** that enables peer connections between mentees and mentors within the student community. It belongs to the broader category of **education-focused social platforms**, with a distinct twist- it’s not about showcasing accomplishments, but about creating **intentional, goal-driven mentorship connections.**  
Unlike generic networking tools, MentorMe streamlines the mentorship journey: from finding a mentor, to requesting support, to staying connected. Think *Linkedin, but built entirely around students helping students grow* \- one connection at a time.

## Story

MentorMe was created to solve a deeply personal and widespread problem: **students often don’t know where to go for guidance**. Whether it’s choosing a career path, applying to internships, learning a new skill, or just figuring out what’s next \- the journey is often overwhelming, especially for students without built-in support systems.

What makes MentorMe different is its **peer-driven structure**. Unlike traditional mentorship models that rely on professional outreach or cold networking, MentorMe empowers **students to mentor other students** \- forming a loop of guidance, learning, and growth.

In this system:

- **Only mentees can initiate a connection \-** keeping the platform low-pressure for mentors and international for mentees.  
- **Mentors can accept or decline** \- maintaining autonomy and trust.  
- Once accepted, **a connection is formed** and tracked in a dedicated space \- enabling follow-up session scheduling, and relational building.

The idea was born from seeing how much potential and knowledge exists within student communities \- but how little of it gets shared. MentorMe gives that potential a structure, a platform, and a purpose.

## Market

MentorMe is designed for university/college students (primary group).  
College students often:

- Feel uncertain about career decisions  
- Struggle to find relatable guidance  
- Desire  mentorship, but don’t know how or where to start. 

### Why MentorMe for College Students?

- Most platforms like Linkedin are too formal or intimidating  
- Cold outreach rarely results in real connection  
- They prefer talking to someone “just a few steps ahead” who understands their journey.

MentorMe provides a **familiar, social environment** tailored for students \- removing friction from finding mentorship, and making it part of their learning process.

In the future, the platform could expand to include:

- Alumni networks  
- Professional mentors  
- Organization-based mentoring (e.g. student orgs or clubs)

## Habit 

MentorMe is designed to create **meaningful, recurring engagement** without overwhelming users. The core interaction loop is simple and intentional.

### For Mentees:

1. **Browse a feed of available mentors** via search of the top number of recommendations.  
2. **Send a connection request** to someone aligned with their goals or interests.  
3. If accepted, the connection appears on their **Connections page.**   
4. From there further actions such as creating sessions, creating tasks, and building a relationship overtime.

### For Mentors:

1. **Receive requests** from mentees.  
2. **Accept or decline** based on availability or interest.  
3. Stay in control of how and when they engage, reducing pressure.

## Scope 

The current version of MentorMe delivers the **core building blocks** for students-to-student mentorship.

### What’s built now:

* **Role-based onboarding:** users can join as a mentee or mentor  
* **Connection System**: profiles reflect what users are lookin

**Scope:** An app that connects students with mentors in their major for one-one academic and career guidance through profile matching .

## Product Spec

Mentor Me is an app where students can browse in search for a suitable mentor that has strength in their area of interest. It is designed to be an informative, supportive, and beginner friendly community. Students can receive advice from mentors registered on the app, and explore school courses, and career topics such as getting an internship or full-time offer.

## User Roles

Mentee: a user looking for academic guidance.  
Mentor: a user who provides support within the same major.

## User Personas

1. Faith, 17, is new to college and moderately tech-savvy. She’ll use the app weekly to ask questions and stay on track. She’s motivated by wanting guidance on courses and adjusting to college life. Her pain point is feeling lost and unsure where to start.  
2. Transfer Olu, 20, is a tech-savvy transfer student in his junior year. He’ll check the app often to get quick, relevant insights. He wants to help catch up and fit into his new program. His pain point is lacking insider knowledge about his department.  
3. Samuel, 22, is a senior who’s confident with tech and checks MentorMe a few times a week. He’s motivated to give back and support underclassmen. His pain point is balancing mentoring with his busy schedule.  
4. Olivia, 21, is a junior, highly organized and loves iMessage. She uses the app to mentor 3-4 students and boosts her leadership skills. She keeps record of all her mentorship and  mentee’s feedback for her portfolio. Her pain point is managing time and keeping communication focused.

## User Stories

1. As a mentee, I want to create a profile, so mentors can learn about me.  
2. As a mentor, I want to create a profile and list my strengths, so that mentees can find me.  
3. As a user, I want to log out of my account, so that I can protect my privacy  
4. As a mentee, I want to browse mentors in my major, so that I can choose who to connect with.  
5. As a mentee, I want to filter mentors by availability or area of support to find the best match.  
6. As a mentee, I want to send a mentorship request to a mentor to start a connection.  
7. As a mentor, I want to see all of the new mentorship  requests, so that I can respond quickly.  
8. As a mentor, I want to accept or reject mentorship requests, so that I can respond quickly.  
9. As a mentee or mentor, I want to view my active mentorship connections in one place.  
10. As a mentee or mentor, I want to end a mentorship connection if needed, to keep my network  up to date.  
11. As a mentee, I want to see all of my pending requests, so  I can remove  them incase I change my mind.

## Required

* Users can create an account as a mentee or mentor.  
* Users can log in to their account.  
* Mentee can browse mentors in their major  
* Mentee can send mentorship request  
* Mentor can receive and view mentorship request  
* Mentor can accept or decline mentorship request  
* Users can view their active mentorship connections  
* User can end an existing mentorship connection

## Optional

* Proper error handling pop up modal  
* Dark & Light Mode Toggle  
* Task Assignment


### Screen Archetypes

*ie. wireframes*

![][image2]

![][image3]

![][image4]

### **Data Model**

Mentor/Mentee  table

| Column name | type | description |
| :---- | :---- | :---- |
| id | integer | Primary key |
| name | string | Name of mentee |
| email | string | School email address of mentee |
| role | enum | Either mentee or mentor |
| School | string | College or university |
| description | string | Description of why the role |
| major | string | User’s major |
| classification | string | Freshman-Senior |
| bio | Text | Short user bio |
| availability | String | Mentors availability(days) |

Mentorship table

| Column name | type | description |
| :---- | :---- | :---- |
| id | integer | Primary key |
| mentor\_id | integer | Foreign key |
| mentee\_id | integer | Foreign key |
| startedAt | Timestamp | When mentorship was accepted |
| endedAt | Timestamp | When mentorship was ended |
| status | enum | ‘active’, ‘ended |

Mentorship Request

| Column name | type | description |
| :---- | :---- | :---- |
| id | int | Primary key  |
| mentee\_id | int | Foreign key to mentee’s id |
| mentor\_id | int | Foreign key to mentor’s id |
| status | enum | Accepted, pending, declined |
| createdAt | Timestamp | When mentee’s request was sent |
| respondedAt | Timestamp | When mentor accepted/declined request |

### 

### **Server Endpoints**

Authentication

| HTTP Verb | Name | Description | User Stories |
| :---- | :---- | :---- | :---- |
| POST | /auth/signup | Create an account a user (mentee or mentor) | 1 |
| POST | /auth/login | Login to an existing account | 2 |
| GET | /auth/me | Authenticate user before accessing pages | 1,2,3  |
| POST | /auth/logout | Log out users  | 3 |

Mentorship Enpoints

| HTTP Verb | Name | Description | User Stories |
| :---- | :---- | :---- | :---- |
| GET | /mentee/home | Fetches list of available mentors filtered by none active connections or pending requests | 4, 5 |
| GET | /connections?role=MENTEE or /connections?role=MENTOR | Fetches a list of active connections for user based on role | 9 |
| POST | /request | Mentee to send connection requests to mentors. | 6 |
| PATCH | /request/update | Update request status based on mentor’s response to mentee | 7 |
| GET | /requests/mentors | Fetch all requests made to mentors by mentees | 7 |
| POST | /connected | Create mentorship connection when mentor accepts request | 9 |
| PATCH | /connected/updated | Update connection status e.g. end connection | 9 |
| GET | /pending | Get a list of all pending requests for mentees | 11 |
| DELETE | /request/remove/:requestId | Delete request made to mentor | 7 |
| DELETE | /connection/remove/:connectionId | Delete mentorship connection | 10 |

## Project Requirements

* MentorMe  interacts with a database (PostgreSql). Using Prism Client, MentorMe is able to perform CRUD operations to interact with the database.  
* MentorMe fetches college names from the [College Scorecard API](https://collegescorecard.ed.gov/data/api/) to maintain consistency.   
* MentorMe allows users to create an account (sign up) based on the role (mentee or mentor)  they want to play when using the app. Registered  users can sign in and log out. Session is maintained for logged in users unless they sign out.  
* MentorMe has multiple views and page layouts are different for mentors and mentees.  
  * **Welcome Page**: same for both mentors and mentees. Users can pick their role for the app.  
  * **SignUp Page**: allows new  users to register their information.  
  * **Login Page**: allows returning users to login with email and password.  
  * **Mentee’s Home Page**: shows all the available mentors to mentee, pending requests, and recommended mentors based on profile, and connections made by similar mentees.  
  * **Mentor’s Home Page**: shows all the requests made to mentor and button to either accept or reject.  
  * **Connections Page**: same for both mentors and mentees. Shows all active connections for users.  
* MentorMe demonstrates interesting cursor interaction by a custom tooltip that displays a mentor’s school  on profile picture hover.  
* MentorMe has pages (components) with complex and custom layout.  
* Loading State shows when the app opens and when pages refresh.

## Technical Challenges

### Technical Challenge \#1 \- Recommendation System

#### What

**Overview**: A recommendation system that recommends mentors to mentees based on common interest or goals.  
The recommendation feature would be by the side of the mentee’s page as the pending requests.  
For the recommendation, I’d use a dataset that can produce similarity between mentee and mentor.

#### How

Recommend the most relevant mentors to a mentee based on profile similarity and mentor experience.

Part 1: Content-Based Matching (Profile Similarity)  
Match mentors to mentees based on share profile attributes

* Use interests, school, and major to score mentors based on relevance  
* Weight common interests based on their popularity in the system  
* Filter out mentors who are already connected to mentee or have been sent a request  
* Return a top number of mentors with highest similarity scores. 


Part 2: Experience-Based Matching (Mentor History)  
Recommend mentors who’ve successfully worked with similar mentees (Connected)

* Identify other mentees who are similar to the current one based on shared interests, school, and major.  
* Score mentors based on how many of those similar mentees they have already mentored.  
* Add a small bonus for mentors who’ve had more mentorship experience  
* Get a top number of mentors ranked by relevance and experience.

Part 3: Bio Description Matching (Users Bio)  
This pseudocode outlines a method for calculating TF-IDF and Cosine Similarity to find resemblances between a mentee's interests and various mentor skills. The process involves:

1. **Text Preparation:** Combining mentee and mentor texts, tokenizing them, and cleaning them by removing special characters and stopwords.  
2. **Vocabulary Creation:** Identifying all unique words and mapping them to numerical indices for matrix representation.  
3. **TF-IDF Calculation:** Generating a Term Frequency (TF) matrix to count word occurrences, then calculating Document Frequency (DF) and Inverse Document Frequency (IDF) to create numerical vectors for each text.  
4. **Cosine Similarity:** Computing the cosine similarity between the mentee's interest vector and each mentor's skill vector. This involves calculating dot products and magnitudes to determine the angle (and thus similarity) between them.  
5. **Recommendation Generation:** Mapping the similarity scores to mentor IDs, sorting them in descending order, and extracting the top 10 recommendations based on the highest similarity scores.

References

* [Understanding and implementing TF-IDF in Python](https://medium.com/@coldstart_coder/understanding-and-implementing-tf-idf-in-python-a325d1301484)  
* [Content Based Recommendation](https://www.youtube.com/watch?v=h13Kv1Fla2g)  
* [Implementing tf-idf](https://medium.com/bitgrit-data-science-publication/tf-idf-from-scratch-in-python-ea587d003e9e)

```javascript

```

Goal: Recommend mentors based on mentee profile using weighted, content-based filtering approach.

**Step 1: Data Modeling**  
Add two new tables to the database

1. Interest table  
   * Fields: id, name  
   * One-to-many relation with UserInterest table  
2. UserInterest table  
   * Fields: id, userId, interestId  
   * Many-to-one relation with user

**Step 2: Retrieve Mentee Interests**

1. Get the current mentee ID from session  
2. Fetch their interest IDs and store in menteeInterestIds

**Step 3: Calculate Popular Interest Weights**

1. Fetch all interests and how many users have each  
2. Build an object where interestId is property and userCount is the value  
3. Find the maximum count, maxCount of all the userCounts  
4. For each interest:	  
   * Calculate the weight which is the userCount divided by maxCount  
   * Create an property, value if weight is greater than 0.5

**Step 4: Filter Available Mentors**

1. Get all mentors who:  
   * Do not have an existing connection with the mentee.  
   * Have not sent a request to the mentee.

**Step 5: Score Each Mentor**

1. Loop through each mentor  
   * Intialiaze **score** to 0  
   * For each of their interest IDs:  
     * If it exists in menteeInterestIds, add 1 to score  
     * If it also exists in populatInterests, add weight to score  
   * Additional matching:  
     * If mentor’s school match mentee’s add 1 to score  
     * If mentor’s major match mentee’s add 2 to score  
   * Sava each mentor with a final score.

**Step 6: Return top mentors**

1. Sort mentors by score in descending order  
2. Return the top 10 mentors with their relevant info and score

**Part 2: Recommendation System (Graph-Based Proximity)**  
Goal: Recommend mentors based on how closely they are connected to the current mentee in the mentorship network graph.

**Step 1: Setup**

1. Get the current mentee ID from session  
2. Fetch   
   * All mentees and their mentorships  
   * All mentors and their mentorships

**Step 2: Get all other Mentees**

1. Create a usersConnection map:  
   * For each mentee, store the list of mentorIds they’ve been mentored by  
   * For each mentor, store the list of menteeIds they’ve mentored  
   * This creates the graph where both mentees and mentors are nodes and edges are the mentorship connections.

**Step 3: BFS Traversal to Find Edge Distance to root** 

1. Initialization:  
   * visited object: keep track of visited users  
   * result object: store edge distance from current mentee  
   * Queue: stores the id and edge count to be processed for BFS  
2. While queue is not empty,  
   * Remove the first element in queue  
   * Save the removed element in the result  
   * For each of the neighboring connections,   
     * If not visited, updates the visited to id  
     * Push new element  to queue with updated depth

**Step 4: Filter and Score Mentors**

1. Filter out mentors that do not appear in result  
2. For remaining mentors, map them to:  
   * User detail  
   * Their edge value

**Step 5: Return Sorted Mentors**

1. Sort mentors in ascending order of edge where (the smaller the closer)  
2. Return final ranked mentor list

### Technical Challenge \#2

#### What

**Overview:**

The MentorMe Scheduling System is designed to efficiently connect mentees with new mentors by identifying optimal meeting times. It prioritizes finding available time slots and intelligently resolving any conflicts that arise.

The Scheduling system is a core component of MentorMe that ensures mentees and mentors can meet efficiently without calendar conflicts.

Its primary function is to:

* Match mutual availability between mentees and mentors.  
* Detect and prevent scheduling overlaps.  
* Intelligently resolve conflicts by suggesting an option to reschedule an existing session to free up time slots between connections.

This system is crucial for:

* Providing a smooth and reliable user experience.  
* Maximizing mentor-mentee engagement by making the most of limited availability.  
* Enabling smart session coordination without manual back-and-forth.

#### How

**Part 1: Best Time to Meet**

This section describes the process for identifying suitable meeting times:

1. **Gather & Order Intervals:** Collect all available time intervals for both the mentee and the new mentor and sort them chronologically.  
2. **Apply User Preference:** Identify time intervals where neither party has an existing session, ensuring these free slots align with the user's preferred daily availability. If a day is full, the system moves to the next.  
3. **Present Suggestions:** Propose the most suitable meeting times.

**Part 2: Time Conflict Resolution**

This section details the logic for resolving scenarios where mutual availability is blocked by existing mentee sessions:

1. **Identify Blocking Sessions:** Pinpoint existing sessions preventing the new mentor-mentee meeting.  
2. **Find Rescheduling Options:** Search for new times to reschedule the identified blocking session with the *existing* mentor.  
3. **Return First Successful Option:** The system proposes the first successful rescheduling option that frees up the blocking slot for the new meeting.

Part 3: Cancellability Conflict Resolution 

Upon cancelling a session, algorithm suggest another connection that is available at that time to the mentee.When a mentoring session is canceled, the system's algorithm should proactively identify and suggest alternative connections to the mentee. This ensures that the mentee's learning and development journey remains uninterrupted. The algorithm would consider factors such as the mentee's learning objectives, the mentor's expertise, and the availability of other mentors within the network to provide the most relevant and timely alternative options. This immediate recommendation helps maintain momentum and provides continuous support, minimizing any potential disruption caused by the cancellation

**Input Parameters:**

* \`userId\`: The ID of the user whose schedule has a freed slot.  
* \`startTime\`: The start time of the freed slot.  
* \`endTime\`: The end time of the freed slot.  
* \`otherUserId\` (optional): If provided, suggestions will exclude this user.

**Process:**

1. **Define Freed Slot:** The \`startTime\` and \`endTime\` are combined into a \`freedSlot\` array \`\[startTime, endTime\]\`.  
2. **Retrieve User Role:**  
   * The system fetches the \`role\` of the \`userId\` from the \`prisma.user\` database.  
   * If the user is not found, an empty array is returned.  
3. **Determine Mentorship Type:**  
   * \`isMentee\` is set to \`true\` if the user's role is \`Role.MENTEE\`.  
4. **Fetch Mentorship Connections:**  
   * The system retrieves all mentorships associated with the \`userId\`.  
   * If \`isMentee\` is true, it finds mentorships where the \`menteeId\` matches \`userId\`.  
   * If \`isMentee\` is false (meaning the user is a mentor), it finds mentorships where the \`mentorId\` matches \`userId\`.  
   * The \`mentor\` and \`mentee\` details for each mentorship are included in the results.  
5. **Initialize Suggestions:** An empty array named \`suggestions\` is created to store potential reschedule options.  
6. **Load User Schedule Data:** The \`loadUserData(userId)\` function is called to get the user's free slots (\`userData.freeSlots\`).  
7. **Iterate Through Mentorships:** For each mentorship connection:  
   * **Identify Partner:** The \`partner\` is identified as the mentor if the current user is a mentee, or the mentee if the current user is a mentor.  
   * **Exclude Specific Partner (if \`otherUserId\` provided):** If \`otherUserId\` is provided and matches the \`partner.id\`, this mentorship is skipped.  
   * **Load Partner Schedule Data:** The \`loadUserData(partner.id)\` function is called to get the partner's free slots (\`partnerData.freeSlots\`).  
   * **Check Availability:**  
     * \`userCanUse\`: Checks if the \`freedSlot\` is contained within the \`userFree\` slots using \`containsIntervals()\`.  
     * \`mentorCanUse\`: Checks if the \`freedSlot\` is contained within the \`partnerFree\` slots using \`containsIntervals()\`.  
   * **Add to Suggestions (if both are available):** If both \`userCanUse\` and \`mentorCanUse\` are true, a suggestion object is added to the \`suggestions\` array. This object includes:  
     * \`connectionId\`: The ID of the mentorship.  
     * \`name\`: The name of the partner.  
     * \`withUser\`: The ID of the partner.  
     * \`suggestTime\`: The \`freedSlot\`.  
8. **Return Suggestions:** The algorithm returns the \`suggestions\` array.

**Error Handling:**

* A \`try...catch\` block is used to handle potential errors during the process.  
* If an error occurs, the string "Error getting reschedule options" is returned.

**Assumptions:**

* \`prisma.user\` and \`prisma.mentorship\` are database models accessible via a Prisma client.  
* \`Role.MENTEE\` is a defined enum value.  
* \`loadUserData(userId)\` is an asynchronous function that retrieves a user's free time slots.  
* \`containsIntervals(freeSlots, interval)\` is a function that checks if a given \`interval\` is fully contained within a set of \`freeSlots\`.

**Pseudocode (Detailed Steps)**

**Part 1: Suggest Best Meeting Session**

* **Step 1: Data Modeling:** Add \`Availability\` (id, day, userId, start\_time, end\_time) and \`Session\` (id, menteeId, mentorId, start\_time, end\_time, reason, connectionId) tables. Define an Enum for weekdays.  
* **Step 2: Retrieve Mentee’s Existing Sessions:** Get the mentee's ID, fetch all their sessions, store connected mentor IDs, and organize sessions by day.  
* **Step 3: Retrieve Connected Mentors' Existing Sessions:** For each connected mentor, fetch their availability and sessions, storing them in an object keyed by mentor ID, then by weekday with time intervals.  
* **Step 4: Find Mentee’s Free Slots:** For each day of mentee's availability, subtract booked sessions using interval subtraction to find free slots. Sort and loop through sessions to identify and store free intervals.  
* **Step 5: Find Free Times from Each Mentor:** Repeat the logic from Step 3 for each mentor to get their free slots.  
* **Step 6: Find Overlapping Free Intervals:** For each day, identify overlapping free intervals between the mentee and mentors.  
* **Step 7: Store and Return Result:** Store the results in an object, organized by mentor ID, then by day of the week, with free intervals as values.

**Part 2: Time Conflict Resolution (Fallback)**

* **Step 1: Identify New Mentor’s Free Slots:** Calculate the new mentor's free slots by subtracting their sessions from their availability.  
* **Step 2: Identify Mentors Responsible for Mentee’s Sessions:** Loop through mentee's sessions and store a list of \`{sessionId: int, mentorId: int}\`.  
* **Step 3: Get the First Session That Can Be Rescheduled:**  
  * Iterate through the mentee's sessions (\`S\`).  
  * For each session, find if another time exists for it with the *existing* mentor by calculating the existing mentor's free slots and checking for overlaps with the mentee's free slots.  
  * If a new time exists, identify the \`SessionToReschedule\`, \`newTimeSlot\`, and \`freedBlockedSlot\` (original conflicting slot). If not, continue to the next session.

### Database Integration

Prisma ORM  
PostgreSQL 

### External APIs

College Scorecard API is a free API provided by the US Department of Education.  
[College Scorecard API](https://collegescorecard.ed.gov/data/api/) 

### Authentication

### Visuals and Interactions

* Interesting Cursor Interaction  
* UI Component with Custom Visual Styling  
* Loading State

## Timeline

| MU Week | Project Week | Focus | Tasks & Timelines |
| ----- | ----- | :---- | :---- |
| 4 | 1 | Focus on the components that will serve as the skeleton of your project. You will probably be using most of what you learned in CodePath to set up things like the client and server repositories, initial routing, login / registration, creating a database with object models, etc. | Mentee/Mentor Creation & Authentication Frontend Forms: 2 days Database Setup for users: 2 days Design users table with roles Run migrations to create table Test user creation through Prisma API: POST/users 1-2 days Setup route to handle user registration. Validate input & store user in DB Send a response confirming creation. Authentication \- Login/Sign Up: 2-3days Implement password with bcrypt Create login route (check credentials, return session) Setup express-session for session management Test login/logout functionality Protect private routes (middlewares) |
| 5 | 2 | Week 5 and 6 should be where you focus on the specific requirements of your project. | Main Page \- Connections List of connections (shared between mentee & mentor) Frontend : 2 days UI display mentor list Exclude mentors with existing connections or request APIs: 1 day ‘GET’ method Filter mentors with no active mentorship or pending request List of current mentors (Mentee side) Frontend: 1day APIs: 2 days ‘GET’ to fetch current connections ‘POST’ to create new mentorship requests |
| 6 | 3 | By this point, you should be getting started with your technical challenges as well. | Requests \- Sidebar Frontend: 2 days Sidebar UI showing requests list Different views for mentors and mentees Status indicators (pending, accepted, rejected) APIs: 2 days ‘GET’ filter mentor/mentee id ‘POST’ update request status |
| 7 | 4 | You should focus on finishing your MVP and core requirements. By this point, you should be done with at least one of your technical challenges. | Technical Challenge 1 Backend: 2 days **Data Modeling**: set up Interest and UserInterest tables  **Profile-Based Recommendation Logic:** Implement interest weighting, school/major matching, scoring and sorting logic. **Graph-Based Recommendation:** Implement BFS algorithm for connection distance \+ edge scoring. API Integration Create controller functions, export functions, export endpoints Frontend API integration; GET request method to fetch top recommendations UI component, display recommended mentors on the side bar of the Mentee’s Home Page  |
| 8 | 5 | Continue work on finishing touches and stretch goals for your MVP. By this point, your core functionality and both TAPs should all be in place. It is also a good point to start working on stretch goals that could further expand on the functionality (and technical complexity) of your project. This week you also have to submit your self-review, make sure you allocate enough time for this alongside your final submission for your project\! | Technical Challenge 2 Backend **Availability Modeling:** Design weekly recurring time slots using weekday \+ start/end (Unix) **Session Suggestion Logic:** Compare mentor and mentee availability to generate mutual meeting times. **Conflict Resolution:** Implemented an algorithm to get the first rescheduling options with an existing mentor to free up blocked sessions with a new mentor. API Integration GET request method to get suggested time passing in mentor’s Id Frontend **API integration**: Fetch suggested time and conflict fallback suggestions. **UI**: Display suggested sessions between two connections Empty State: Show fallback text if no time is available  Session History: Display past sessions  Upcoming Session: Display scheduled sessions. |
| 9 | 6 | It’s time to show others what you have built\! Work on a presentation and demo that you will present to other interns to showcase your work. You are also free to continue polishing and expanding on your project\! |  |
| 10 | 7 | For this week, we have a bunch of extra activities prepared to give you a quick dive of what it is to work at Meta. You will find activities around using internal tools and frameworks, and even committing code to our internal repositories. |  |